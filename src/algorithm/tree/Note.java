package algorithm.tree;

public class Note {

    /**
     * 树结构：
     * 1.二叉树
     *
     * 2.线索二叉树
     *
     * 3.赫夫曼树：也称最优二叉树，它是n个带权叶子节点构成的所有二叉树中，带权路径长度最小的二叉树
     *       排序：取出根节点权值最小的两棵二叉树，组成一棵新的二叉树，前面取出来的两棵二叉树是新
     *            二叉的两个子树，根节点的权值是前两取出来的两棵二叉树的根节点的权值之和
     *
     *
     * 4.二叉排序（查找）树（BST）:对于二叉树中的任何一个非叶子节点，要求左子节点比当前节点值小，
     *                          右子节点比当前节点值大
     *                          1).添加节点
     *                          2).查找节点
     *                          3).删除节点
     *
     * 5.平衡二叉树（AVL树）：左子树和右子树的高度差的绝对值不超过1
     *                      1).单旋转
     *                      2).双旋转
     *
     * 6.多路查找树：1).计算机的存储
     *              2).2-3树和2-3-4树
     *              3).B树和B+树
     *   B树要求所有的节点都在同一层
     *   有两个子节点的节点叫二节点，二节点要么有两个子节点，要么没有子节点
     *   有三个子节点的节点叫三节点，三节点要么有三个子节点，要么没有子节点
     *
     *   B树的阶：2-3树是3阶的B树；2-3-4树是4阶的B树，以此类推
     *   B+树：非叶子节点只存储索引信息，不存储数据；叶子节点最右边的指针指向下一个相邻的叶子节点，叶子节点组成一个有序链表
     *
     * 7.散列表：
     */


    /**
    * 二叉树：任何一个节点的子节点数量不超过2
    *
    * 满二叉树：所有叶子节点都在最后一层，而且节点的总数为：2^n-1，n为树的高度
    *
    * 完全二叉树：所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子在左边连续，
    *           倒数第二节的叶子节点在右边连续
    * 完全二叉树的性质：
    *           1.第n个元素的左子节点是：2*n+1
    *           2.第n个元素的右子节点是：2*n+2
    *           3.第n个元素的父节点是：(n-1)/2
    *
    *
    * 二叉树的遍历：前序遍历，中序遍历，后序遍历
    *
    * 顺序存储的二叉树通常情况只考虑完全二叉树
    */

    /**
     * 赫夫曼编码
     */
}
